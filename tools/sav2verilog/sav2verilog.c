//
// sav2verilog.c
// Based on some code from Dave Conroy.
// Heavily modified by Rob Doyle
//

#include <stdio.h>
#include <stdlib.h>

#define JRST   0254000
#define HALT   0254200

typedef struct {
    unsigned int lh;
    unsigned int rh;
} FW;

void usage(const char *prog) {
    fprintf(stderr, "%s: Usage: [infile [outfile]]\n", prog);
}

//
// Data is in the following format:
//
//   Byte 0:   0  B00 B01 B02 B03 B04 B05 B06
//   Byte 1:   0  B07 B08 B09 B10 B11 B12 B13
//   Byte 2:   0  B14 B15 B16 B17 B18 B19 B20
//   Byte 3:   0  B21 B22 B23 B24 B25 B26 B27
//   Byte 4:  B35 B28 B29 B30 B31 B32 B33 B34
//
//   Note the position of B35!
//
// See "TOPS-10 Tape Processing Manual" Section 6.4 entitled "ANSI-ASCII Mode"
// for format definition.
//
// See also document entitled "Dumper and Backup Tape Formats".
//

static unsigned int read_lh(unsigned char * b) {
    return (((b[0] & 0177) << 11) |
            ((b[1] & 0177) <<  4) |
            ((b[2] & 0170) >>  3));
}

static unsigned int read_rh(unsigned char * b) {
    return (((b[2] & 0007) << 15) |
            ((b[3] & 0177) <<  8) |
            ((b[4] & 0177) <<  1) |
            ((b[4] & 0200) >>  7));
}

void rdfwsav(FILE *ifp, FW *dp) {

    unsigned char b[5];
    int size = fread(b, sizeof(char), 5, ifp);

    if (size != 5) {
        printf("Ran out of data.  Size was %d\n", size);
        exit(-1);
    }

    dp->lh = read_lh(b);
    dp->rh = read_rh(b);
}

void rdsav(FILE *ifp, FILE *ofp) {
    FW d1, d2;
    unsigned int last = ~0;

    for (;;) {

        rdfwsav(ifp, &d1);
        //fprintf(stderr, "Read len,,addr = %06o,,%06o\n", d1.lh, d1.rh);

        /* -n,,a-1 */
        if ((d1.lh & 0400000) == 0)
            break;

        do {
            rdfwsav(ifp, &d2);
            d1.rh = (d1.rh + 1) & 0777777;

            if (d1.rh != last + 1) {
#ifdef x18
                fprintf(ofp, "@%x\n", d1.rh * 2);	// Fix the address of the 18-bit data
#else
                fprintf(ofp, "@%x\n", d1.rh);
#endif
            }

            unsigned long long data = (((unsigned long long)d2.lh << 18) +
                                       ((unsigned long long)d2.rh <<  0));

#ifdef x18
            fprintf(ofp, "%05x %05x\t\t// mem[%06o] = %012llo\n", d2.lh, d2.rh, d1.rh, data);
#else
            fprintf(ofp, "%09llx\t\t// mem[%06o] = %012llo\n", data, d1.rh, data);
#endif

            last = d1.rh;
            d1.lh = (d1.lh + 1) & 0777777;

        } while ((d1.lh & 0400000) != 0);

    }

    if (d1.lh == JRST) {
        fprintf(ofp,
                "\n"
                "//\n"
                "// Starting Address is %06o\n"
                "//\n"
                "\n",
                d1.rh);
    } else {
        fprintf(stderr, "Expecting JRST to starting address.\n");
    }

}

int main(int argc, char *argv[]) {
    FILE *ifp = stdin;
    FILE *ofp = stdout;
    switch (argc) {
        default:
            usage(argv[0]);
            exit(EXIT_FAILURE);
            break;
        case 3:
            ofp = fopen(argv[2], "w");
            if (ofp == NULL) {
                fprintf(stderr, "Unable to open output file.\n");
                exit(EXIT_FAILURE);
            }
            // FALLTHRU
        case 2:
            ifp = fopen(argv[1], "r");
            if (ifp == NULL) {
                fprintf(stderr, "Unable to open input file.\n");
                exit(EXIT_FAILURE);
            }
            // FALLTHRU
        case 1:
            ;
            // FALLTHRU
    }

    fprintf(ofp,
            "//\n"
            "// Do not edit this file.\n"
            "// It was created by %s %s %s\n"
            "//\n"
            "\n",
            argv[0], argv[1], argv[2]);

    rdsav(ifp, ofp);
    fclose(ifp);
    fclose(ofp);
    return 0;
}
