################################################################################
##
## KS-10 Processor
##
## Brief
##   This AWK script reads a DEC listing file and extracts the object code.
##
## Details
##   This script is used to merge multiple 18-bit or 36-bit SSRAM
##   initialization files and creates a 36-bit initialization file for
##   simulation.  We use this to merge in 'patches' that are sometimes required
##   for simulation.
##
## File
##   merge36.awk
##
## Author
##   Rob Doyle - doyle (at) cox (dot) net
##
################################################################################
##
## Copyright (C) 2012-2020 Rob Doyle
##
## This source file may be used and distributed without restriction provided
## that this copyright statement is not removed from the file and that any
## derivative work contains the original copyright notice and the associated
## disclaimer.
##
## This source file is free software; you can redistribute it and#or modify it
## under the terms of the GNU Lesser General Public License as published by the
## Free Software Foundation; version 2.1 of the License.
##
## This source is distributed in the hope that it will be useful, but WITHOUT
## ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
## FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public License
## for more details.
##
## You should have received a copy of the GNU Lesser General Public License
## along with this source; if not, download it from
## http://www.gnu.org/licenses/lgpl.txt
##
################################################################################

#
# Max function
#

function max(a, b) {
    return (a < b) ? b : a;
}

#
# Start
#

BEGIN {
    FS="\t\t// mem\\[|\\] = "
    printf "/*\n";
    printf " * " filename "\n";
    printf " * Do not edit this file.  It was created by an awk script as part of the build\n"
    printf " * process.\n"
    printf " *\n";
    printf " */\n";
    printf "\n";
    lastaddr = 0;
}

#
# Match 18-bit input files
#  This parses the comments - which is consistent between x18 and x36 files.
#
#

/^[0-9a-f][0-9a-f][0-9a-f][0-9a-f][0-9a-f] [0-9a-f][0-9a-f][0-9a-f][0-9a-f][0-9a-f]\t\t\/\/ mem\[[0-7][0-7][0-7][0-7][0-7][0-7]\] = .*/ {
    #printf $1 "::" $2 "::" $3 "\n"
    addr = strtonum("0" $2);
    data = strtonum("0" $3);
    lastaddr = max(lastaddr, addr);
    if ((map[addr] != "") && (map[addr] != data)) {
        printf("// Address %6o was modified from %012o to %012o.\n", addr, map[addr], data);
    }
    map[addr] = data;
}

#
# Match 36-bit input files
#  This parses the comments - which is consistent between x18 and x36 files.
#

/^[0-9a-f][0-9a-f][0-9a-f][0-9a-f][0-9a-f][0-9a-f][0-9a-f][0-9a-f][0-9a-f]\t\t\/\/ mem\[[0-7][0-7][0-7][0-7][0-7][0-7]\] = .*/ {
    #printf $1 "::" $2 "::" $3 "\n"
    addr = strtonum("0" $2);
    data = strtonum("0" $3);
    lastaddr = max(lastaddr, addr);
    if ((map[addr] != "") && (map[addr] != data)) {
        printf("// Address %6o was modified from %012o to %012o.\n", addr, map[addr], data);
    }
    map[addr] = data;
}

#
# Write 36-bit sorted output to file
#

END {
   prevaddr = 0;
   for (addr = 0; addr <= lastaddr; addr++) {
       if (map[addr] != "") {
           data = map[addr];
           if (addr != prevaddr + 1) {
               printf "@%x\n", addr;
           }
           printf "%09x\t\t// mem[%06o] = %012o\n", data, addr, data;
           prevaddr = addr;
       } else {
           printf "%09x\t\t// mem[%06o] = %012o\n", 0, addr, 0;
           prevaddr = addr;
       }
   }
}
